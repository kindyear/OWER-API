"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkProcessor = void 0;
const protocol_js_1 = require("../../../protocol/protocol.js");
const NetworkStorage_js_1 = require("./NetworkStorage.js");
/** Dispatches Network domain commands. */
class NetworkProcessor {
    #browsingContextStorage;
    #networkStorage;
    constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
    }
    async addIntercept(params) {
        if (params.phases.length === 0) {
            throw new protocol_js_1.InvalidArgumentException('At least one phase must be specified.');
        }
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases,
        });
        // TODO: Add try/catch. Remove the intercept if CDP Fetch commands fail.
        await this.#applyIntercepts();
        return {
            intercept,
        };
    }
    continueRequest(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    continueResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    continueWithAuth(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    async failRequest(params) {
        const networkId = params.request;
        const blockedRequest = this.#getBlockedRequest(networkId);
        const { request: fetchId, phase } = blockedRequest;
        if (phase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is in 'AuthRequired' phase`);
        }
        await this.#networkStorage
            .getRequest(networkId)
            ?.failRequest(fetchId, 'Failed');
        this.#networkStorage.removeBlockedRequest(networkId);
        // TODO: Remove from network request map?
        return {};
    }
    provideResponse(_params) {
        throw new protocol_js_1.UnknownCommandException('Not implemented yet.');
    }
    async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        // TODO: Add try/catch. Remove the intercept if CDP Fetch commands fail.
        await this.#applyIntercepts();
        return {};
    }
    /** Applies all existing network intercepts to all CDP targets concurrently. */
    async #applyIntercepts() {
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchApply();
        }));
    }
    /**
     * Returns the blocked request associated with the given network ID.
     * If none, throws a NoSuchRequestException.
     */
    #getBlockedRequest(networkId) {
        const blockedRequest = this.#networkStorage.getBlockedRequest(networkId);
        if (!blockedRequest) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        return blockedRequest;
    }
    static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
                case 'string': {
                    try {
                        new URL(urlPattern.pattern);
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${urlPattern.pattern}': ${error}`);
                    }
                    return urlPattern;
                }
                case 'pattern':
                    if (urlPattern.protocol === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                    }
                    if (urlPattern.hostname === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                    }
                    if ((urlPattern.hostname?.length ?? 0) > 0) {
                        if (urlPattern.protocol?.match(/^file/i)) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                        }
                        if (urlPattern.hostname?.includes(':')) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                        }
                    }
                    if (urlPattern.port === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                    }
                    try {
                        new URL(NetworkStorage_js_1.NetworkStorage.buildUrlPatternString(urlPattern));
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`${error}`);
                    }
                    return urlPattern;
            }
        });
    }
}
exports.NetworkProcessor = NetworkProcessor;
//# sourceMappingURL=NetworkProcessor.js.map